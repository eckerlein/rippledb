---
title: Materialization
description: Project changes into queryable domain tables
---

import { Callout } from 'fumadocs-ui/components/callout';

# Materialization

Materialization projects your change log into domain tables for fast queries.

<Callout type="info">
This guide covers **server-side** materialization. On the client, the `Store` interface 
handles applying changes to local state. See [Client Sync](/docs/guides/client-sync) for client patterns.
</Callout>

## Why Materialize?

Without materialization, reading current state requires replaying all changes:

```ts
// Slow: scan entire change log
const changes = await db.pull({ stream, cursor: null });
const currentState = changes.reduce((acc, change) => {
  // Apply each change with LWW...
}, {});
```

With materialization, queries are instant:

```sql
-- Fast: direct table lookup
SELECT * FROM todos WHERE id = 'todo-1';
```

## How It Works

<Diagram
  height={380}
  nodes={[
    { id: 'append', x: 20, y: 10, label: 'db.append()' },
    { id: 'load', x: 20, y: 70, label: '1. Load existing tags' },
    { id: 'lww', x: 20, y: 140, label: ['2. Apply field-level LWW', '(compare HLC timestamps)'] },
    { id: 'domain', x: 20, y: 220, label: '3. Update domain table' },
    { id: 'tags', x: 20, y: 290, label: '4. Update tags table' },
    { id: 'tags-read', relativeTo: 'load', anchor: 'right', offset: { x: 40 }, variant: 'label', label: 'ripple_tags' },
    { id: 'todos', relativeTo: 'domain', anchor: 'right', offset: { x: 40 }, variant: 'label', label: 'todos' },
    { id: 'tags-write', relativeTo: 'tags', anchor: 'right', offset: { x: 40 }, variant: 'label', label: 'ripple_tags' },
  ]}
  edges={[
    { from: 'append', to: 'load', orthogonal: true },
    { from: 'load', to: 'lww', orthogonal: true },
    { from: 'lww', to: 'domain', orthogonal: true },
    { from: 'domain', to: 'tags', orthogonal: true },
    { from: 'tags-read', to: 'load', fromSide: 'left', toSide: 'right', dashed: true, animated: true, orthogonal: true },
    { from: 'domain', to: 'todos', fromSide: 'right', toSide: 'left', dashed: true, animated: true, orthogonal: true },
    { from: 'tags', to: 'tags-write', fromSide: 'right', toSide: 'left', dashed: true, animated: true, orthogonal: true },
  ]}
/>

## Configuration

### tableMap

Maps entity names to database tables:

```ts
{
  tableMap: {
    todos: 'todos',        // Entity 'todos' → table 'todos'
    users: 'app_users',    // Entity 'users' → table 'app_users'
  }
}
```

### fieldMap

Maps schema fields to database columns:

```ts
{
  fieldMap: {
    todos: {
      id: 'id',
      title: 'title',
      done: 'is_completed',  // Schema 'done' → column 'is_completed'
    }
  }
}
```

<Callout type="info">
**Without fieldMap**, only the `ripple_tags` table is updated. The domain table is unchanged.

**With fieldMap**, both `ripple_tags` and the domain table are updated.
</Callout>

## Field-Level LWW in Action

When a change arrives, each field is compared independently:

```ts
// Incoming change
{
  entity: 'todos',
  entityId: 'todo-1',
  patch: { title: 'New Title', done: true },
  tags: { title: '1001:0:client-A', done: '1002:0:client-B' }
}

// Existing state (from ripple_tags)
{
  values: { title: 'Old Title', done: false },
  tags: { title: '1000:0:server', done: '1003:0:client-C' }
}

// Result after LWW:
// - title: '1001:0:client-A' > '1000:0:server' → accept 'New Title'
// - done: '1002:0:client-B' < '1003:0:client-C' → keep false

// Final state
{
  values: { title: 'New Title', done: false },
  tags: { title: '1001:0:client-A', done: '1003:0:client-C' }
}
```

## Choosing a Materializer

| If you use... | Materializer |
|--------------|--------------|
| `db-sqlite` | `materialize-db` |
| `db-turso` | `materialize-db` |
| `db-drizzle` | `materialize-drizzle` |

### materialize-db Example

```ts
import { SqliteDb } from '@rippledb/db-sqlite';
import { createMaterializerConfig, SqliteDialect } from '@rippledb/materialize-db';

const db = new SqliteDb<MySchema>({
  filename: './data.db',
  materializer: ({ db }) => createMaterializerConfig({
    db,
    dialect: SqliteDialect,
    tableMap: { todos: 'todos' },
    fieldMap: { todos: { id: 'id', title: 'title', done: 'done' } },
  }),
});
```

### materialize-drizzle Example

```ts
import { SqliteDb } from '@rippledb/db-sqlite';
import { createDrizzleSyncMaterializerConfig } from '@rippledb/materialize-drizzle';
import { drizzle } from 'drizzle-orm/better-sqlite3';

const db = new SqliteDb<MySchema>({
  filename: './data.db',
  materializer: ({ db }) => {
    const drizzleDb = drizzle(db);
    return createDrizzleSyncMaterializerConfig(drizzleDb, {
      tableMap: { todos: todosTable },
      tagsTableDef: tagsTable,
      getTableConfig,
      fieldMap: { todos: { id: 'id', title: 'title', done: 'done' } },
    });
  },
});
```

## Tags Table

The materializer maintains a `ripple_tags` table:

```sql
CREATE TABLE ripple_tags (
  entity TEXT NOT NULL,
  id TEXT NOT NULL,
  data TEXT NOT NULL,       -- JSON: current field values
  tags TEXT NOT NULL,       -- JSON: field → HLC timestamp
  deleted INTEGER NOT NULL, -- Tombstone flag
  deleted_tag TEXT,         -- Delete timestamp
  PRIMARY KEY (entity, id)
);
```

## Custom Materializers

For advanced cases, implement a custom executor:

```ts
const db = new SqliteDb<MySchema>({
  filename: './data.db',
  materializer: ({ db }) => ({
    tableMap: { todos: 'todos' },
    fieldMap: { todos: { id: 'id', title: 'title', done: 'done' } },
    executor: {
      ensureTagsTable: async () => {
        // Create tags table
      },
      loadTags: async (entity, id) => {
        // Return TagsRow or null
      },
      saveTags: async (entity, id, dataJson, tagsJson) => {
        // Upsert tags row
      },
      removeTags: async (entity, id, dataJson, tagsJson, deletedTag) => {
        // Upsert with deleted flag
      },
      saveEntity: async (tableName, id, columns, values, updates) => {
        // Upsert domain table
      },
    },
  }),
});
```

## Atomicity

All materialization happens in the same transaction as `db.append()`:

1. Insert change to log
2. Load existing tags
3. Apply LWW
4. Update domain table
5. Update tags table
6. Commit

If any step fails, everything rolls back.

## Performance Tips

1. **Index the tags table** on `(entity, id)`
2. **Use fieldMap sparingly** — only for entities you query directly
3. **Batch changes** — append multiple changes in one call

## Related

- [materialize-db](/docs/adapters/materialize-db) — SQL-based materializer
- [materialize-drizzle](/docs/adapters/materialize-drizzle) — Drizzle materializer
- [Core Concepts](/docs/getting-started/concepts) — Understand LWW
