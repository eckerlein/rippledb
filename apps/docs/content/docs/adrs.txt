Perfect. This is exactly the right moment to “lock in” the thinking.

Below is a **complete initial ADR set** for Converge, covering **all major decisions we made**, written so that:

* a future LLM (or human) can **reconstruct the intent**
* no decision looks accidental
* alternatives are explicitly documented
* scope creep is discouraged unless a *new ADR* is written

You can drop these into `docs/adr/` as-is.
I’ll number them sequentially and keep them crisp but explicit.

---

# ADR-0001: Local Storage Is the Source of Truth

## Status

Accepted

## Context

Converge is intended to support offline-first and multi-user applications.
The system must remain correct when the network is unavailable and must converge deterministically across replicas.

A decision is required on whether canonical state lives:

* in memory
* on the server
* or in durable local storage

## Decision

Converge treats **durable local storage as the source of truth** on the client.

All UI state is derived from local storage.
In-memory caches (e.g. UI caches) are explicitly non-authoritative.

## Alternatives Considered

* In-memory truth with persistence layer (TinyBase-style)
* Server-authoritative state with local cache
* Hybrid memory + disk authority

## Consequences

* Offline correctness is guaranteed
* Debugging and inspection are easier
* Memory usage is predictable
* UI reactivity must be explicitly wired
* Persistence logic is unavoidable but centralized

---

# ADR-0002: Replication Is Log-Based (Append-Only), Not State-Based

## Status

Accepted

## Context

To support offline usage, partial connectivity, and deterministic convergence, replicas must synchronize changes reliably.

State-based sync (sending full snapshots) complicates conflict resolution and recovery.

## Decision

Converge uses an **append-only change log** as the replication primitive.

Clients pull changes using a cursor and push local changes via an outbox.

## Alternatives Considered

* Snapshot-based sync
* Periodic full-state reconciliation
* Bidirectional state diffs

## Consequences

* Sync is resumable and replayable
* Partial failures are recoverable
* History can be inspected or compacted later
* Storage grows unless compacted (explicitly deferred)

---

# ADR-0003: Field-Level LWW Using Hybrid Logical Clocks (HLC)

## Status

Accepted

## Context

Concurrent updates to the same entity fields must resolve deterministically across replicas.

Row-level “last write wins” causes unnecessary data loss and conflicts.

## Decision

Converge resolves conflicts using **field-level Last-Write-Wins**, ordered by **Hybrid Logical Clock (HLC) tags**.

Each mutable field has its own tag:

```
wallMillis:counter:nodeId
```

## Alternatives Considered

* Row-level LWW
* Vector clocks
* CRDTs for all data
* Server-side conflict resolution

## Consequences

* Deterministic convergence
* Reduced conflict scope
* Increased schema verbosity (tags per field)
* Requires careful delete modeling (tombstones)

---

# ADR-0004: Deletes Are Modeled as Tombstones

## Status

Accepted

## Context

Concurrent delete/update scenarios can cause “resurrection” if deletes are treated as row removal.

## Decision

Deletes are represented as **tombstones**:

* `deleted = true`
* `deleted_tag = <hlc>`

Deletes participate in LWW like any other field.

## Alternatives Considered

* Hard deletes
* Server-only deletes
* Per-row delete markers without tags

## Consequences

* Deletes are conflict-resolvable
* Resurrection is prevented
* Queries must filter on `deleted`
* Cleanup/compaction is a future concern

---

# ADR-0005: Distinguish Row Queries from List Queries

## Status

Accepted

## Context

Different query types have fundamentally different invalidation semantics.

Treating all queries uniformly leads to either stale data or excessive invalidation complexity.

## Decision

Converge explicitly distinguishes:

* **Row queries** (fetch by primary key)
* **List queries** (WHERE, ORDER BY, JOIN, aggregates, pagination)

Each category has its own invalidation strategy.

## Alternatives Considered

* Uniform query treatment
* Automatic dependency graph inference
* Reactive joins

## Consequences

* Invalidation logic becomes simpler
* Developers must classify queries correctly
* Enables predictable correctness guarantees

---

# ADR-0006: Row Queries Are Invalidated Precisely by ID

## Status

Accepted

## Context

Row queries fetch a single entity by ID.
Their membership does not change unless the entity is deleted.

## Decision

Row queries are invalidated **precisely**:

* update → invalidate `["entity", id]`
* delete → invalidate and remove cached row

## Alternatives Considered

* Broad invalidation for all queries
* Row dependency graphs

## Consequences

* Minimal re-fetching
* High performance for detail views
* Requires reliable DbEvent emission

---

# ADR-0007: List Queries Use Broad Invalidation and Rerun

## Status

Accepted

## Context

List queries may contain:

* WHERE clauses
* ORDER BY clauses
* JOINs
* aggregates
* pagination

Without parsing SQL or re-implementing query logic in JS, it is impossible to determine whether a change affects list membership or ordering.

## Decision

Converge **always invalidates and reruns list queries broadly** when dependent entities change.

Precision is intentionally sacrificed for correctness and simplicity.

## Alternatives Considered

* SQL AST parsing
* Query DSL with JS evaluation
* Incremental view maintenance
* In-memory reactive joins

## Consequences

* Lists are always correct
* Some refetches are unnecessary but safe
* Complexity is dramatically reduced
* Performance relies on DB efficiency and batching

---

# ADR-0008: Sorting Requires the Same Invalidation Strategy as Filtering

## Status

Accepted

## Context

Sorting changes row ordering and pagination boundaries.
A field change used in ORDER BY may reorder the entire list.

## Decision

Sorting is treated identically to filtering:

* any change to dependent entities invalidates the list query
* list queries are rerun entirely

## Alternatives Considered

* Incremental reorder logic
* Partial re-sorting

## Consequences

* Consistent behavior across filters and sorts
* Simplified mental model
* Predictable pagination correctness

---

# ADR-0009: Performance Is Achieved via Batched Reads, Not Join-Based Reactivity

## Status

Accepted

## Context

Normalized data access patterns cause many point reads (N+1 problem).

Using client-side joins introduces invalidation complexity.

## Decision

Converge introduces a **batch loader** abstraction:

* reads are collected per tick/RAF
* executed as a single bulk query
* results are split back to callers

Batching is independent of UI frameworks or caches.

## Alternatives Considered

* Client-side joins
* In-memory materialized views
* Reactive data graphs

## Consequences

* Performance comparable to joins
* Simple invalidation model
* Works across all callers (UI, services, background tasks)

---

# ADR-0010: UI Cache Integration Is Optional and Decoupled

## Status

Accepted

## Context

Different applications use different UI frameworks and caching strategies.

The core library must not depend on a specific UI solution.

## Decision

Converge:

* emits neutral `DbEvent`s from the write path
* provides **optional UI integration helpers**
* does not couple core logic to TanStack Query or any framework

## Alternatives Considered

* Built-in UI cache
* Framework-specific core APIs

## Consequences

* Core remains portable
* UI integration requires explicit wiring
* Multiple UI adapters can coexist

---

# ADR-0011: List Query Dependency Mapping Is Explicit (Registry-Based)

## Status

Accepted

## Context

Broad invalidation still needs to be scoped to relevant list queries.

Hardcoding invalidation logic across the app leads to duplication and errors.

## Decision

Converge supports an **optional list registry**:

* maps list query key prefixes to dependent entities
* used by UI adapters to invalidate queries

This registry is declarative and non-magical.

## Alternatives Considered

* Implicit dependency inference
* No abstraction (manual invalidation everywhere)

## Consequences

* Low boilerplate
* Explicit policy
* Still optional
* No SQL awareness required

---

# ADR-0012: CRDTs Are Explicitly Out of Core Scope

## Status

Accepted

## Context

CRDTs (e.g. Yjs) solve different problems than LWW-based relational sync.

Mixing CRDT semantics into the core would complicate guarantees and APIs.

## Decision

Converge does **not** include CRDT logic in the core.

CRDTs may be integrated later via:

* separate controllers
* separate persistence
* separate transports

## Alternatives Considered

* CRDT-only system
* Hybrid LWW/CRDT core

## Consequences

* Core remains simple and deterministic
* Rich text and presence require additional modules
* Future extensibility is preserved

---

# ADR-0013: Complexity Is Rejected in Favor of Predictability

## Status

Accepted

## Context

Many potential optimizations introduce significant complexity and hidden failure modes.

## Decision

When choosing between:

* complex incremental optimization
* simple rerun-based correctness

Converge **chooses simplicity and correctness**.

Optimizations are deferred until proven necessary.

## Alternatives Considered

* Aggressive optimization
* Smart diffing
* Query introspection

## Consequences

* Easier reasoning
* Fewer edge-case bugs
* Acceptable performance for intended use cases

---

## Final Note (Meta-ADR)

> Any future change that contradicts one of these ADRs **must introduce a new ADR** explaining why the original decision no longer holds.

This is how the architecture stays coherent.

---

If you want next, I can:

* generate an **ADR index** with links
* help you tag “superseded” ADRs later
* or map each ADR to concrete modules/files in the monorepo

You’re doing this exactly like a serious systems project should be done.
