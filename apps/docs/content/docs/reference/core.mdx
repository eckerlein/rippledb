---
title: "@rippledb/core"
description: HLC timestamps, Change types, and pure merge logic
---

import { Callout } from 'fumadocs-ui/components/callout';

# @rippledb/core

The foundation package containing HLC timestamps, Change types, and pure merge logic. Has zero dependencies.

## Installation

```bash
pnpm add @rippledb/core
```

## Hybrid Logical Clocks (HLC)

### Types

```ts
// HLC string format: "wallMs:counter:nodeId"
type Hlc = `${number}:${number}:${string}`;

type ParsedHlc = {
  wallMs: number;
  counter: number;
  nodeId: string;
};

type HlcState = {
  lastWallMs: number;
  counter: number;
  nodeId: string;
};
```

### Functions

#### `createHlcState(nodeId: string): HlcState`

Create a new HLC state for a node.

```ts
import { createHlcState } from '@rippledb/core';

const state = createHlcState('server-abc123');
// { lastWallMs: 0, counter: 0, nodeId: 'server-abc123' }
```

#### `tickHlc(state: HlcState, nowMs: number): Hlc`

Generate a new HLC timestamp. Mutates `state` to ensure monotonicity.

```ts
import { createHlcState, tickHlc } from '@rippledb/core';

const state = createHlcState('node-1');
const ts1 = tickHlc(state, Date.now());
const ts2 = tickHlc(state, Date.now());
// ts2 > ts1 (always increasing)
```

#### `observeHlc(state: HlcState, remote: Hlc, nowMs: number): Hlc`

Update local state after observing a remote HLC. Ensures local clock stays ahead.

```ts
import { createHlcState, observeHlc } from '@rippledb/core';

const state = createHlcState('node-1');
const remoteTs = '1706123456789:5:node-2';
const localTs = observeHlc(state, remoteTs, Date.now());
// localTs >= remoteTs
```

#### `parseHlc(hlc: Hlc): ParsedHlc`

Parse an HLC string into its components.

```ts
import { parseHlc } from '@rippledb/core';

const parsed = parseHlc('1706123456789:5:node-1');
// { wallMs: 1706123456789, counter: 5, nodeId: 'node-1' }
```

#### `formatHlc(p: ParsedHlc): Hlc`

Format ParsedHlc back to string.

```ts
import { formatHlc } from '@rippledb/core';

const hlc = formatHlc({ wallMs: 1706123456789, counter: 5, nodeId: 'node-1' });
// '1706123456789:5:node-1'
```

#### `compareHlc(a: Hlc, b: Hlc): number`

Compare two HLCs. Returns -1, 0, or 1.

```ts
import { compareHlc } from '@rippledb/core';

compareHlc('1000:0:a', '1001:0:b'); // -1 (a < b)
compareHlc('1000:0:a', '1000:0:a'); // 0 (equal)
compareHlc('1000:1:a', '1000:0:a'); // 1 (a > b)
```

## Changes

### Types

```ts
type ChangeKind = 'upsert' | 'delete';

type RippleSchema = Record<string, Record<string, unknown>>;

type Change<S extends RippleSchema, E extends EntityName<S>> = {
  stream: string;
  entity: E;
  entityId: string;
  kind: ChangeKind;
  patch: Partial<S[E]>;
  tags: Partial<Record<keyof S[E], Hlc>>;
  hlc: Hlc;
};
```

### Functions

#### `makeUpsert<S, E>(input): Change<S, E>`

Create an upsert change. Auto-generates tags if not provided.

```ts
import { makeUpsert } from '@rippledb/core';

type MySchema = { todos: { id: string; title: string; done: boolean } };

const change = makeUpsert<MySchema>({
  stream: 'user-123',
  entity: 'todos',
  entityId: 'todo-1',
  patch: { title: 'Buy milk', done: false },
  hlc: '1706123456789:0:server-1',
});
// {
//   stream: 'user-123',
//   entity: 'todos',
//   entityId: 'todo-1',
//   kind: 'upsert',
//   patch: { title: 'Buy milk', done: false },
//   tags: { title: '1706123456789:0:server-1', done: '1706123456789:0:server-1' },
//   hlc: '1706123456789:0:server-1',
// }
```

**Input type:**

```ts
type UpsertChangeInput<S, E> = {
  stream: string;
  entity: E;
  entityId: string;
  patch: Partial<S[E]>;
  hlc: Hlc;
  tags?: Partial<Record<keyof S[E], Hlc>>; // Optional, auto-generated if omitted
};
```

#### `makeDelete<S, E>(input): Change<S, E>`

Create a delete change (tombstone).

```ts
import { makeDelete } from '@rippledb/core';

const change = makeDelete<MySchema>({
  stream: 'user-123',
  entity: 'todos',
  entityId: 'todo-1',
  hlc: '1706123456789:0:server-1',
});
// {
//   stream: 'user-123',
//   entity: 'todos',
//   entityId: 'todo-1',
//   kind: 'delete',
//   patch: {},
//   tags: {},
//   hlc: '1706123456789:0:server-1',
// }
```

**Input type:**

```ts
type DeleteChangeInput<S, E> = {
  stream: string;
  entity: E;
  entityId: string;
  hlc: Hlc;
};
```

## Schema Definition

Define your schema as a TypeScript type:

```ts
// Each key is an entity name
// Each value is the shape of that entity's data
type MySchema = {
  todos: {
    id: string;
    title: string;
    done: boolean;
    createdAt: string;
  };
  users: {
    id: string;
    name: string;
    email: string;
  };
  comments: {
    id: string;
    todoId: string;
    text: string;
  };
};
```

<Callout type="info">
The schema type is used for compile-time type checking only. It doesn't create database tables.
</Callout>

## Runtime Schema Descriptor

For runtime entity discovery and metadata attachment, use `defineSchema()` to create a schema descriptor:

### `defineSchema<S>(entities): SchemaDescriptor<S>`

Creates a runtime schema descriptor that provides entity discovery, property discovery, and extensible metadata attachment.

```ts
import { defineSchema } from '@rippledb/core';

const schema = defineSchema({
  todos: { id: '', title: '', done: false },
  users: { id: '', name: '', email: '' },
});

// Runtime entity discovery
schema.entities; // ['todos', 'users']
schema.entityMap.has('todos'); // true

// Runtime property discovery
schema.getFields('todos'); // ['id', 'title', 'done']
schema.hasField('todos', 'title'); // true
schema.hasField('todos', 'missing'); // false

// Type inference still works
type MySchema = typeof schema.schema;
const db = new SqliteDb<MySchema>({ filename: './data.db' });
```

**Note:** The values in the entity objects are used to infer field names at runtime. Use sample/default values (empty strings, `false`, `0`, etc.) that match your TypeScript types.

### Schema Descriptor API

```ts
type SchemaDescriptor<S extends RippleSchema> = {
  // Original schema (for type inference and runtime introspection)
  readonly schema: S;
  
  // Array of entity names for runtime discovery
  readonly entities: readonly EntityName<S>[];
  
  // Map for O(1) entity lookup
  readonly entityMap: ReadonlyMap<EntityName<S>, true>;
  
  // Map of entity names to their field names
  readonly entityFields: ReadonlyMap<EntityName<S>, readonly string[]>;
  
  // Get field names for a specific entity
  getFields<E extends EntityName<S>>(entity: E): readonly string[];
  
  // Check if an entity has a specific field
  hasField<E extends EntityName<S>>(entity: E, field: string): boolean;
  
  // Extensible metadata (Zod schemas, Drizzle tables, etc.)
  readonly extensions: ReadonlyMap<string, SchemaExtension>;
  
  // Attach metadata extensions
  extend<K extends string, E extends SchemaExtension>(
    key: K,
    extension: E,
  ): SchemaDescriptor<S>;
};
```

### Extensions

Extensions allow adapters to attach metadata to schema descriptors:

```ts
// Example: Attach Zod schemas (future @rippledb/zod integration)
const schemaWithZod = schema.extend('zod', {
  todos: z.object({ id: z.string(), title: z.string() }),
  users: z.object({ id: z.string(), name: z.string() }),
});

// Example: Attach Drizzle table mappings (future integration)
const schemaWithDrizzle = schema.extend('drizzle', {
  tableMap: { todos: todosTable, users: usersTable },
});
```

### Use Cases

- **Controllers / client-query**: Build `api.todos`, `api.users` dynamically from `descriptor.entities`
- **Zod validation**: Attach schemas for per-entity validation (see [issue #7](https://github.com/eckerlein/rippledb/issues/7))
- **Drizzle adapters**: Attach table definitions as single source of truth
- **Materializers**: Read `tableMap` from descriptor instead of separate config

## Related

- [Core Concepts](/docs/getting-started/concepts) — Understand HLCs and Changes
- [Server Reference](/docs/reference/server) — Db interface for persistence
- [Client Reference](/docs/reference/client) — Store interface for local state
