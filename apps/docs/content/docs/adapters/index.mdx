---
title: Adapters Overview
description: Choose the right database adapter and materializer for your use case
---

import { Cards, Card } from 'fumadocs-ui/components/card';
import { Callout } from 'fumadocs-ui/components/callout';
import { Diagram } from '@/components/diagram';

# Adapters

RippleDB uses adapters to integrate with different runtimes, databases, and ORMs. There are four types:

1. **Database Adapters (`db-*`)** — Store the change log and handle append/pull
2. **Materializers (`materialize-*`)** — Project changes into domain tables
3. **Stores (`store-*`)** — Client-side local truth store (what the UI reads from)
4. **Bindings (`bind-*`)** — Wire DbEvents to UI cache invalidation (e.g. TanStack Query)

## Decision Tree

### Which Database Adapter?

<Diagram
  height={280}
  nodes={[
    { id: 'q1', x: 160, y: 10, label: 'Are you using Drizzle ORM?' },
    { id: 'drizzle', x: 40, y: 120, label: 'db-drizzle' },
    { id: 'q2', x: 280, y: 120, label: 'What database?' },
    { id: 'sqlite', x: 140, y: 220, label: 'db-sqlite' },
    { id: 'turso', relativeTo: 'sqlite', anchor: 'right', offset: { x: 30 }, alignY: 'center', label: 'db-turso' },
    { id: 'memory', relativeTo: 'turso', anchor: 'right', offset: { x: 30 }, alignY: 'center', label: 'db-memory' },
  ]}
  edges={[
    { from: 'q1', to: 'drizzle', orthogonal: true, label: 'Yes' },
    { from: 'q1', to: 'q2', orthogonal: true, label: 'No' },
    { from: 'q2', to: 'sqlite', orthogonal: true, label: 'SQLite' },
    { from: 'q2', to: 'turso', orthogonal: true, label: 'Turso' },
    { from: 'q2', to: 'memory', orthogonal: true, label: 'In-memory' },
  ]}
/>

### Which Materializer?

<Diagram
  height={180}
  nodes={[
    { id: 'q', x: 140, y: 10, label: 'Using db-drizzle?' },
    { id: 'drizzle', x: 20, y: 110, label: 'materialize-drizzle' },
    { id: 'db', x: 280, y: 110, label: 'materialize-db' },
  ]}
  edges={[
    { from: 'q', to: 'drizzle', orthogonal: true, label: 'Yes' },
    { from: 'q', to: 'db', orthogonal: true, label: 'No' },
  ]}
/>

## Quick Reference

| Adapter | Best For | Sync/Async | Notes |
|---------|----------|------------|-------|
| `db-sqlite` | Local servers, Electron, tests | Sync | Uses `better-sqlite3` |
| `db-turso` | Edge deployments, serverless | Async | Uses `@libsql/client` |
| `db-drizzle` | Existing Drizzle projects | Both | Database-agnostic |
| `db-memory` | Unit tests | Sync | No persistence |
| `store-memory` | Unit tests | Sync | Client truth store, no persistence |
| `store-sqlite` | Production client apps | Sync | Persistent, SQL WHERE clauses |
| `materialize-db` | Raw SQL projects | Both | Works with db-sqlite, db-turso |
| `materialize-drizzle` | Drizzle projects | Both | Type-safe queries |

## Database Adapters

<Cards>
  <Card 
    title="db-sqlite" 
    description="Production-ready SQLite adapter using better-sqlite3"
    href="/docs/adapters/db-sqlite"
  />
  <Card 
    title="db-turso" 
    description="Edge-ready adapter for Turso and libSQL"
    href="/docs/adapters/db-turso"
  />
  <Card 
    title="db-drizzle" 
    description="Database-agnostic adapter using Drizzle ORM"
    href="/docs/adapters/db-drizzle"
  />
  <Card 
    title="db-memory" 
    description="In-memory adapter for testing"
    href="/docs/adapters/db-memory"
  />
</Cards>

## Materializers

<Cards>
  <Card 
    title="materialize-db" 
    description="SQL-based materializer for raw SQL projects"
    href="/docs/adapters/materialize-db"
  />
  <Card 
    title="materialize-drizzle" 
    description="Type-safe materializer using Drizzle schemas"
    href="/docs/adapters/materialize-drizzle"
  />
</Cards>

## Materialization

Materialization is how *you, the app developer*, get a fast “current state” view of your data at all times.

RippleDB stores an **append-only change log**. That log is great for sync, but you usually don’t want to replay changes on every read. A materializer incrementally applies incoming changes into your **domain tables** (a live snapshot), so your application can query current rows efficiently.

### Who is this for?

- **You want normal reads**: `SELECT * FROM todos WHERE ...` (or Drizzle queries) against current state.
- **You need a live snapshot**: UI and APIs read domain tables that always reflect the latest applied changes.
- **You care about performance**: reads stay fast as history grows.

### RippleDB does not need materialization

RippleDB does not require materialization. You can use the change log directly if you want.
All our adapters on the client side consume changes directly from the change log.

#### When this might change

A Snapshot is a powerful tool to keep new clients in sync with the latest state before moving them to the change log.
But this is not implemented yet. And will be optional in the future yet recommended for production use.

### When you might skip it

- Prototypes/tests where you only care about the log
- You already maintain your own projection layer and want RippleDB only for replication history

## Stores

Stores implement the client-side `Store` contract (`@rippledb/client`). They are optional but recommended if you want a consistent local "truth DB" that emits `DbEvent`s for UI reactivity.

<Cards>
  <Card
    title="store-memory"
    description="In-memory Store implementation for tests and examples"
    href="/docs/adapters/store-memory"
  />
  <Card
    title="store-sqlite"
    description="SQLite-based Store with persistent storage and SQL WHERE clauses"
    href="/docs/adapters/store-sqlite"
  />
</Cards>

## Bindings

Bindings wire RippleDB's `DbEvent`s to UI cache invalidation. When your Store applies changes, it emits events like `{ entity: 'todos', kind: 'update', id: '1' }`. A binding translates these into cache invalidations for your UI framework.

<Cards>
  <Card
    title="bind-tanstack-query"
    description="TanStack Query invalidation binding (React, Vue, Solid, Svelte)"
    href="/docs/adapters/bind-tanstack-query"
  />
</Cards>

## Pairing Guide

<Callout type="info">
These are the **supported pairings** we test and guarantee (especially around atomicity/transactions).
Other combinations can be made to work, but you may need custom wiring to ensure the Db adapter and materializer share the same transaction/connection semantics.
</Callout>

| Database Adapter | Recommended Materializer |
|------------------|--------------------------|
| `db-sqlite` | `materialize-db` |
| `db-turso` | `materialize-db` |
| `db-drizzle` | `materialize-drizzle` |
| `db-memory` | Custom or none |

### Why These Pairings?

- **db-sqlite + materialize-db**: Both speak raw SQL and can share the same connection/transaction.
- **db-turso + materialize-db**: Both use the libSQL driver and transaction model.
- **db-drizzle + materialize-drizzle**: Both use Drizzle’s schema + query builder, keeping things type-safe and consistent.

### Can I mix-and-match?

Yes — the limitation is usually **support/guarantees**, not a hard technical block.

For example, `db-sqlite + materialize-drizzle` could work if you:

- create a Drizzle instance on top of the same SQLite connection used by `db-sqlite`
- ensure materialization runs inside the same `db.append()` transaction boundary

If you don’t share the transaction/connection, you can break the atomicity guarantee (log written but materialization fails, or vice versa).

## Atomicity

All adapters guarantee atomicity within `db.append()`:

- Changes are written to the log
- Materialization happens in the same transaction
- If anything fails, everything rolls back

### Why is this important?

Atomicity prevents “half-applied” state, which is one of the hardest classes of bugs in sync systems:

- If the **log write succeeds** but **materialization fails**, reads from your domain tables won’t match what replication history says happened.
- If **materialization succeeds** but the **log write fails/rolls back**, clients may never receive the change again (history is missing) even though your tables changed.

Keeping log + materialized state in one transaction makes failures safe: either the whole change is visible everywhere, or it’s as if it never happened.

<Callout type="warning">
With `db-drizzle`, set `isSync: true` for synchronous drivers like `better-sqlite3` to ensure proper transaction handling. See the [db-drizzle docs](/docs/adapters/db-drizzle#issync-flag) for details.
</Callout>

## Custom Adapters

You can implement your own adapters by following the `Db` interface:

```ts
interface Db<S extends RippleSchema> {
  append(stream: string, changes: Change<S>[]): Promise<{ accepted: number }>;
  pull(stream: string, cursor: number | null): Promise<{ changes: Change<S>[]; cursor: number }>;
  close(): void;
}
```

See the [Server Reference](/docs/reference/server) for the full interface definition.
