---
title: materialize-db
description: SQL-based state materializer for raw SQL projects
---

import { Callout } from 'fumadocs-ui/components/callout';

# @rippledb/materialize-db

A SQL-based materializer that projects changes into domain tables. Works with `db-sqlite` and `db-turso`.

## Installation

<InstallCommandTabs packages="@rippledb/materialize-db" />

## What Is Materialization?

Materialization is the process of applying changes to your domain tables so you can query them efficiently.

**Without materialization:**
```sql
-- Expensive: replay all changes to compute current state
SELECT * FROM ripple_changes 
WHERE entity = 'todos' AND entity_id = 'todo-1'
ORDER BY seq;
-- Then apply LWW in code...
```

**With materialization:**
```sql
-- Fast: directly query current state
SELECT * FROM todos WHERE id = 'todo-1';
```

## Basic Usage

```ts
import { SqliteDb } from '@rippledb/db-sqlite';
import { createSyncSqlExecutor } from '@rippledb/materialize-db';

const db = new SqliteDb<MySchema>({
  filename: './data.db',
  materializer: ({ db }) => {
    const sqlConfig = {
      dialect: 'sqlite',
      tableMap: { todos: 'todos', users: 'users' },
      fieldMap: {
        todos: { id: 'id', title: 'title', done: 'done' },
        users: { id: 'id', name: 'name', email: 'email' },
      },
    } as const;
    return {
      ...sqlConfig,
      executor: createSyncSqlExecutor(db, sqlConfig),
    };
  },
});
```

## How It Works

1. **Change arrives** via `db.append()`
2. **Load existing tags** from `ripple_tags` table
3. **Apply field-level LWW** — compare HLC timestamps per field
4. **Update domain table** with winning values
5. **Update tags table** with new timestamps

All happens atomically in the same transaction.

## Configuration

### `dialect`

Built-in SQL dialect. Currently supported:

- `'sqlite'` — For SQLite and Turso

```ts
import { createSyncSqlExecutor } from '@rippledb/materialize-db';

const sqlConfig = {
  dialect: 'sqlite',
  tableMap: { todos: 'todos' },
  fieldMap: { todos: { id: 'id', title: 'title', done: 'done' } },
} as const;

materializer: ({ db }) => ({
  ...sqlConfig,
  executor: createSyncSqlExecutor(db, sqlConfig),
});
```

### `tableMap`

Maps entity names (from your schema) to database table names.

```ts
type MySchema = {
  todos: { id: string; title: string; done: boolean };
  users: { id: string; name: string };
};

const sqlConfig = {
  dialect: 'sqlite',
  tableMap: {
    todos: 'todos',      // Entity 'todos' → table 'todos'
    users: 'app_users',  // Entity 'users' → table 'app_users'
  },
} as const;

materializer: ({ db }) => ({
  ...sqlConfig,
  executor: createSyncSqlExecutor(db, sqlConfig),
});
```

### `fieldMap`

Maps schema field names to database column names. If omitted, field names are used as-is.

```ts
const sqlConfig = {
  dialect: 'sqlite',
  tableMap: { todos: 'todos' },
  fieldMap: {
    todos: {
      id: 'id',
      title: 'title',
      done: 'is_done',  // Schema field 'done' → column 'is_done'
    },
  },
} as const;

materializer: ({ db }) => ({
  ...sqlConfig,
  executor: createSyncSqlExecutor(db, sqlConfig),
});
```

<Callout type="info">
If `fieldMap` is provided for an entity, changes to that entity will update the domain table. Without `fieldMap`, only the `ripple_tags` table is updated.
</Callout>

### `tagsTable`

Name of the table storing entity tags/metadata. Default: `'ripple_tags'`

```ts
const sqlConfig = {
  dialect: 'sqlite',
  tableMap: { todos: 'todos' },
  tagsTable: 'my_ripple_tags',
} as const;

materializer: ({ db }) => ({
  ...sqlConfig,
  executor: createSyncSqlExecutor(db, sqlConfig),
});
```

## Tags Table Schema

The materializer automatically creates a `ripple_tags` table:

```sql
CREATE TABLE ripple_tags (
  entity TEXT NOT NULL,
  id TEXT NOT NULL,
  data TEXT NOT NULL,      -- JSON: current field values
  tags TEXT NOT NULL,      -- JSON: field → HLC timestamp
  deleted INTEGER NOT NULL DEFAULT 0,
  deleted_tag TEXT,
  PRIMARY KEY (entity, id)
);
```

## Custom Commands

For databases not covered by built-in dialects, provide custom SQL commands:

```ts
import { createSyncSqlExecutor } from '@rippledb/materialize-db';

const sqlConfig = {
  tableMap: { todos: 'todos' },
  loadCommand: (tagsTable) => `
    SELECT data, tags, deleted, deleted_tag 
    FROM ${tagsTable} 
    WHERE entity = ? AND id = ?
  `,
  saveCommand: (tagsTable) => `
    INSERT INTO ${tagsTable} (entity, id, data, tags, deleted, deleted_tag)
    VALUES (?, ?, ?, ?, 0, NULL)
    ON CONFLICT (entity, id) DO UPDATE SET
      data = excluded.data,
      tags = excluded.tags,
      deleted = 0,
      deleted_tag = NULL
  `,
  removeCommand: (tagsTable) => `
    INSERT INTO ${tagsTable} (entity, id, data, tags, deleted, deleted_tag)
    VALUES (?, ?, ?, ?, 1, ?)
    ON CONFLICT (entity, id) DO UPDATE SET
      data = excluded.data,
      tags = excluded.tags,
      deleted = 1,
      deleted_tag = excluded.deleted_tag
  `,
} as const;

materializer: ({ db }) => ({
  ...sqlConfig,
  executor: createSyncSqlExecutor(db, sqlConfig),
});
```

## Custom Executor

For full control, provide a custom executor:

```ts
materializer: ({ db }) => ({
  tableMap: { todos: 'todos' },
  fieldMap: { todos: { id: 'id', title: 'title', done: 'done' } },
  executor: {
    ensureTagsTable: async () => {
      // Create tags table if needed
    },
    loadTags: async (entity, id) => {
      // Load and return TagsRow or null
    },
    saveTags: async (entity, id, dataJson, tagsJson) => {
      // Upsert tags row
    },
    removeTags: async (entity, id, dataJson, tagsJson, deletedTag) => {
      // Upsert tags row with deleted flag
    },
    saveEntity: async (tableName, id, columns, values, updates) => {
      // Upsert domain table row
    },
  },
});
```

## Sync vs Async

For SQLite with `better-sqlite3`, use the sync variants:

```ts
import { createSyncSqlExecutor } from '@rippledb/materialize-db';

// Sync executor for better-sqlite3
materializer: ({ db }) => {
  const sqlConfig = {
    dialect: 'sqlite',
    tagsTable: 'ripple_tags',
    tableMap: { todos: 'todos' },
    fieldMap: { todos: { id: 'id', title: 'title', done: 'done' } },
  } as const;
  return {
    ...sqlConfig,
    executor: createSyncSqlExecutor(db, sqlConfig),
  };
}
```

For async databases (like Turso), use `createSqlExecutor`:

```ts
import { createSqlExecutor } from '@rippledb/materialize-db';

materializer: ({ db }) => {
  const sqlConfig = {
    dialect: 'sqlite',
    tableMap: { todos: 'todos' },
    fieldMap: { todos: { id: 'id', title: 'title', done: 'done' } },
  } as const;
  return {
    ...sqlConfig,
    executor: createSqlExecutor(sqlConfig, db),
  };
}
```

## Domain Table Requirements

Your domain tables must:

1. Have an `id` column (or whatever your schema uses as primary key)
2. Have columns for each field in `fieldMap`
3. Already exist (the materializer doesn't create them)

```sql
CREATE TABLE todos (
  id TEXT PRIMARY KEY,
  title TEXT,
  done INTEGER  -- SQLite doesn't have boolean, use 0/1
);
```

## Related

- [db-sqlite](/docs/adapters/db-sqlite) — SQLite database adapter
- [db-turso](/docs/adapters/db-turso) — Turso database adapter
- [materialize-drizzle](/docs/adapters/materialize-drizzle) — Type-safe alternative
- [Core Concepts](/docs/getting-started/concepts) — Understand field-level LWW
