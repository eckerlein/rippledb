import { resolve, dirname } from 'node:path';
import { writeFileSync, mkdirSync } from 'node:fs';
import type { DrizzleCodegenConfig } from '../config.js';
import { createRequire } from 'node:module';
import { createConsoleLogger, type Logger } from '../logger.js';

const require = createRequire(import.meta.url);
const packageJson = require('../../package.json');

/**
 * Maps Drizzle column data types to RippleDB field descriptor calls
 */
function drizzleTypeToRipple(
  dataType: string,
  isNotNull: boolean,
  warn?: (message: string) => void,
): string {
  let base: string;

  switch (dataType) {
    case 'string':
    case 'text':
    case 'varchar':
    case 'char':
    case 'uuid':
      base = 's.string()';
      break;
    case 'number':
    case 'integer':
    case 'smallint':
    case 'bigint':
    case 'real':
    case 'double':
    case 'float':
    case 'decimal':
    case 'numeric':
      base = 's.number()';
      break;
    case 'boolean':
      base = 's.boolean()';
      break;
    default:
      // Default to string for unknown types
      warn?.(`Unknown Drizzle type "${dataType}", defaulting to s.string()`);
      base = 's.string()';
  }

  // If nullable (not notNull), add .optional()
  if (!isNotNull) {
    base += '.optional()';
  }

  return base;
}

interface DrizzleColumn {
  dataType: string;
  notNull: boolean;
}

interface TableInfo {
  name: string;
  exportName: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  table: any;
}

/**
 * Generate RippleDB schema from Drizzle tables
 */
export async function generateFromDrizzle(
  config: DrizzleCodegenConfig,
  cwd: string,
  options?: { logger?: Logger },
): Promise<void> {
  const entitiesPath = resolve(cwd, config.entities);
  const outputPath = resolve(cwd, config.output);
  const logger = options?.logger ?? createConsoleLogger();

  // Dynamically import drizzle-orm utilities
  type DrizzleOrm = typeof import('drizzle-orm');

  let drizzleOrm: DrizzleOrm;
  try {
    drizzleOrm = await import('drizzle-orm');
  } catch {
    logger.error?.('Error: drizzle-orm is required for Drizzle codegen');
    logger.error?.('Install it with: pnpm add -D drizzle-orm');
    process.exit(1);
  }

  const { getTableName, getTableColumns, is, Table } = drizzleOrm;

  // Import the entities file using jiti for TypeScript support
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let entityModule: Record<string, any>;
  try {
    const { createJiti } = await import('jiti');
    const jiti = createJiti(cwd);
    entityModule = (await jiti.import(entitiesPath)) as Record<string, unknown>;
  } catch (err) {
    logger.error?.(`Error loading entities file: ${entitiesPath}`);
    logger.error?.(err instanceof Error ? err.message : String(err));
    process.exit(1);
  }

  // Find all Drizzle tables in the module
  const tables: TableInfo[] = [];

  for (const [exportName, value] of Object.entries(entityModule)) {
    if (is(value, Table)) {
      const tableName = getTableName(value);
      tables.push({ name: tableName, exportName, table: value });
    }
  }

  if (tables.length === 0) {
    logger.error?.('No Drizzle tables found in entities file');
    logger.error?.(`File: ${entitiesPath}`);
    logger.error?.('Make sure you export Drizzle table definitions');
    process.exit(1);
  }

  logger.log?.(
    `Found ${tables.length} table${tables.length === 1 ? '' : 's'}: ${tables.map((t) => t.name).join(', ')}`,
  );

  // Build the schema definition
  const entityDefinitions: string[] = [];

  for (const { name, table } of tables) {
    const columns = getTableColumns(table) as Record<string, DrizzleColumn>;
    const fieldDefinitions: string[] = [];

    for (const [columnName, column] of Object.entries(columns)) {
      const fieldType = drizzleTypeToRipple(column.dataType, column.notNull, logger.warn);
      fieldDefinitions.push(`    ${columnName}: ${fieldType},`);
    }

    entityDefinitions.push(`  ${name}: {\n${fieldDefinitions.join('\n')}\n  },`);
  }

  // Generate the output file content
  const output = `// AUTO-GENERATED by @rippledb/cli v${packageJson.version} - DO NOT EDIT
// Source: ${config.entities}
// Generated: ${new Date().toISOString()}

import { defineSchema, s, type InferSchema } from '@rippledb/core';

export const schema = defineSchema({
${entityDefinitions.join('\n')}
});

export type Schema = InferSchema<typeof schema>;
`;

  // Ensure output directory exists
  const outputDir = dirname(outputPath);
  mkdirSync(outputDir, { recursive: true });

  // Write the output file
  writeFileSync(outputPath, output, 'utf-8');
  logger.log?.(`Generated: ${outputPath}`);
}
